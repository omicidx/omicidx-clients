/*
 * OmicIDX
 *
 *     The OmicIDX API documentation is available in three forms:  - [RapiDoc](/docs) - [OpenAPI/Swagger Interactive](/swatterdoc) - [ReDoc (more readable in some ways)](/redoc)  
 *
 * API version: 0.99
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package omicidx_client

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"reflect"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// GEOApiService GEOApi service
type GEOApiService service

// ByAccessionGeoPlatformAccessionGetOpts Optional parameters for the method 'ByAccessionGeoPlatformAccessionGet'
type ByAccessionGeoPlatformAccessionGetOpts struct {
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
}

/*
ByAccessionGeoPlatformAccessionGet Platform By Accession
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accession An accession for lookup
 * @param optional nil or *ByAccessionGeoPlatformAccessionGetOpts - Optional Parameters:
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
@return map[string]interface{}
*/
func (a *GEOApiService) ByAccessionGeoPlatformAccessionGet(ctx _context.Context, accession string, localVarOptionals *ByAccessionGeoPlatformAccessionGetOpts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/geo/platform/{accession}"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", _neturl.QueryEscape(parameterToString(accession, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ByAccessionGeoPlatformAccessionGet_1Opts Optional parameters for the method 'ByAccessionGeoPlatformAccessionGet_1'
type ByAccessionGeoPlatformAccessionGet_1Opts struct {
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
}

/*
ByAccessionGeoPlatformAccessionGet_0 Platform By Accession
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accession An accession for lookup
 * @param optional nil or *ByAccessionGeoPlatformAccessionGet_1Opts - Optional Parameters:
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
@return map[string]interface{}
*/
func (a *GEOApiService) ByAccessionGeoPlatformAccessionGet_1(ctx _context.Context, accession string, localVarOptionals *ByAccessionGeoPlatformAccessionGet_1Opts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/geo/platform/{accession}"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", _neturl.QueryEscape(parameterToString(accession, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ByAccessionGeoSamplesAccessionGetOpts Optional parameters for the method 'ByAccessionGeoSamplesAccessionGet'
type ByAccessionGeoSamplesAccessionGetOpts struct {
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
}

/*
ByAccessionGeoSamplesAccessionGet Sample By Accession
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accession An accession for lookup
 * @param optional nil or *ByAccessionGeoSamplesAccessionGetOpts - Optional Parameters:
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
@return map[string]interface{}
*/
func (a *GEOApiService) ByAccessionGeoSamplesAccessionGet(ctx _context.Context, accession string, localVarOptionals *ByAccessionGeoSamplesAccessionGetOpts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/geo/samples/{accession}"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", _neturl.QueryEscape(parameterToString(accession, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ByAccessionGeoSamplesAccessionGet_2Opts Optional parameters for the method 'ByAccessionGeoSamplesAccessionGet_2'
type ByAccessionGeoSamplesAccessionGet_2Opts struct {
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
}

/*
ByAccessionGeoSamplesAccessionGet_0 Sample By Accession
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accession An accession for lookup
 * @param optional nil or *ByAccessionGeoSamplesAccessionGet_2Opts - Optional Parameters:
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
@return map[string]interface{}
*/
func (a *GEOApiService) ByAccessionGeoSamplesAccessionGet_2(ctx _context.Context, accession string, localVarOptionals *ByAccessionGeoSamplesAccessionGet_2Opts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/geo/samples/{accession}"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", _neturl.QueryEscape(parameterToString(accession, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ByAccessionGeoSeriesAccessionGetOpts Optional parameters for the method 'ByAccessionGeoSeriesAccessionGet'
type ByAccessionGeoSeriesAccessionGetOpts struct {
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
}

/*
ByAccessionGeoSeriesAccessionGet Series By Accession
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accession An accession for lookup
 * @param optional nil or *ByAccessionGeoSeriesAccessionGetOpts - Optional Parameters:
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
@return map[string]interface{}
*/
func (a *GEOApiService) ByAccessionGeoSeriesAccessionGet(ctx _context.Context, accession string, localVarOptionals *ByAccessionGeoSeriesAccessionGetOpts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/geo/series/{accession}"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", _neturl.QueryEscape(parameterToString(accession, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ByAccessionGeoSeriesAccessionGet_3Opts Optional parameters for the method 'ByAccessionGeoSeriesAccessionGet_3'
type ByAccessionGeoSeriesAccessionGet_3Opts struct {
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
}

/*
ByAccessionGeoSeriesAccessionGet_0 Series By Accession
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accession An accession for lookup
 * @param optional nil or *ByAccessionGeoSeriesAccessionGet_3Opts - Optional Parameters:
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
@return map[string]interface{}
*/
func (a *GEOApiService) ByAccessionGeoSeriesAccessionGet_3(ctx _context.Context, accession string, localVarOptionals *ByAccessionGeoSeriesAccessionGet_3Opts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/geo/series/{accession}"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", _neturl.QueryEscape(parameterToString(accession, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ForPlatformGeoPlatformsAccessionSamplesGetOpts Optional parameters for the method 'ForPlatformGeoPlatformsAccessionSamplesGet'
type ForPlatformGeoPlatformsAccessionSamplesGetOpts struct {
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    Size optional.Int32
    Cursor optional.String
}

/*
ForPlatformGeoPlatformsAccessionSamplesGet Samples For Platform
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accession An accession for lookup
 * @param optional nil or *ForPlatformGeoPlatformsAccessionSamplesGetOpts - Optional Parameters:
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
 * @param "Size" (optional.Int32) - 
 * @param "Cursor" (optional.String) - 
@return map[string]interface{}
*/
func (a *GEOApiService) ForPlatformGeoPlatformsAccessionSamplesGet(ctx _context.Context, accession string, localVarOptionals *ForPlatformGeoPlatformsAccessionSamplesGetOpts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/geo/platforms/{accession}/samples"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", _neturl.QueryEscape(parameterToString(accession, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ForPlatformGeoPlatformsAccessionSamplesGet_4Opts Optional parameters for the method 'ForPlatformGeoPlatformsAccessionSamplesGet_4'
type ForPlatformGeoPlatformsAccessionSamplesGet_4Opts struct {
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    Size optional.Int32
    Cursor optional.String
}

/*
ForPlatformGeoPlatformsAccessionSamplesGet_0 Samples For Platform
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accession An accession for lookup
 * @param optional nil or *ForPlatformGeoPlatformsAccessionSamplesGet_4Opts - Optional Parameters:
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
 * @param "Size" (optional.Int32) - 
 * @param "Cursor" (optional.String) - 
@return map[string]interface{}
*/
func (a *GEOApiService) ForPlatformGeoPlatformsAccessionSamplesGet_4(ctx _context.Context, accession string, localVarOptionals *ForPlatformGeoPlatformsAccessionSamplesGet_4Opts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/geo/platforms/{accession}/samples"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", _neturl.QueryEscape(parameterToString(accession, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GeoFieldsEntityGet Mapping
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param entity
@return map[string]interface{}
*/
func (a *GEOApiService) GeoFieldsEntityGet(ctx _context.Context, entity string) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/geo/fields/{entity}"
	localVarPath = strings.Replace(localVarPath, "{"+"entity"+"}", _neturl.QueryEscape(parameterToString(entity, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GeoPlatformsGetOpts Optional parameters for the method 'GeoPlatformsGet'
type GeoPlatformsGetOpts struct {
    Q optional.String
    Size optional.Int32
    Cursor optional.String
    FacetSize optional.Int32
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    Facets optional.Interface
}

/*
GeoPlatformsGet Platform
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *GeoPlatformsGetOpts - Optional Parameters:
 * @param "Q" (optional.String) -  The query, using [lucene query syntax](https://lucene.apache.org/core/3_6_0/queryparsersyntax.html)
 * @param "Size" (optional.Int32) - 
 * @param "Cursor" (optional.String) -  The cursor is used to scroll through results. For a query with more results than `size`, the result will include `cursor` in the result json. Use that value here and re-issue the query. The next set or results will be returned. When no more results are available, the `cursor` will again be empty in the result json.
 * @param "FacetSize" (optional.Int32) -  The maximum number of records returned for each facet. This has no effect unless one or more facets are specified.
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
 * @param "Facets" (optional.Interface of []string) -  A list of strings identifying fields for faceted search results. Simple term faceting is used here, meaning that fields that are short text and repeated across records will be binned and counted.
@return ResponseModel
*/
func (a *GEOApiService) GeoPlatformsGet(ctx _context.Context, localVarOptionals *GeoPlatformsGetOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/geo/platforms"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FacetSize.IsSet() {
		localVarQueryParams.Add("facet_size", parameterToString(localVarOptionals.FacetSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Facets.IsSet() {
		t:=localVarOptionals.Facets.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("facets", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("facets", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GeoPlatformsGet_5Opts Optional parameters for the method 'GeoPlatformsGet_5'
type GeoPlatformsGet_5Opts struct {
    Q optional.String
    Size optional.Int32
    Cursor optional.String
    FacetSize optional.Int32
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    Facets optional.Interface
}

/*
GeoPlatformsGet_0 Platform
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *GeoPlatformsGet_5Opts - Optional Parameters:
 * @param "Q" (optional.String) -  The query, using [lucene query syntax](https://lucene.apache.org/core/3_6_0/queryparsersyntax.html)
 * @param "Size" (optional.Int32) - 
 * @param "Cursor" (optional.String) -  The cursor is used to scroll through results. For a query with more results than `size`, the result will include `cursor` in the result json. Use that value here and re-issue the query. The next set or results will be returned. When no more results are available, the `cursor` will again be empty in the result json.
 * @param "FacetSize" (optional.Int32) -  The maximum number of records returned for each facet. This has no effect unless one or more facets are specified.
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
 * @param "Facets" (optional.Interface of []string) -  A list of strings identifying fields for faceted search results. Simple term faceting is used here, meaning that fields that are short text and repeated across records will be binned and counted.
@return ResponseModel
*/
func (a *GEOApiService) GeoPlatformsGet_5(ctx _context.Context, localVarOptionals *GeoPlatformsGet_5Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/geo/platforms"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FacetSize.IsSet() {
		localVarQueryParams.Add("facet_size", parameterToString(localVarOptionals.FacetSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Facets.IsSet() {
		t:=localVarOptionals.Facets.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("facets", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("facets", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GeoSamplesGetOpts Optional parameters for the method 'GeoSamplesGet'
type GeoSamplesGetOpts struct {
    Q optional.String
    Size optional.Int32
    Cursor optional.String
    FacetSize optional.Int32
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    Facets optional.Interface
}

/*
GeoSamplesGet Samples
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *GeoSamplesGetOpts - Optional Parameters:
 * @param "Q" (optional.String) -  The query, using [lucene query syntax](https://lucene.apache.org/core/3_6_0/queryparsersyntax.html)
 * @param "Size" (optional.Int32) - 
 * @param "Cursor" (optional.String) -  The cursor is used to scroll through results. For a query with more results than `size`, the result will include `cursor` in the result json. Use that value here and re-issue the query. The next set or results will be returned. When no more results are available, the `cursor` will again be empty in the result json.
 * @param "FacetSize" (optional.Int32) -  The maximum number of records returned for each facet. This has no effect unless one or more facets are specified.
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
 * @param "Facets" (optional.Interface of []string) -  A list of strings identifying fields for faceted search results. Simple term faceting is used here, meaning that fields that are short text and repeated across records will be binned and counted.
@return ResponseModel
*/
func (a *GEOApiService) GeoSamplesGet(ctx _context.Context, localVarOptionals *GeoSamplesGetOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/geo/samples"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FacetSize.IsSet() {
		localVarQueryParams.Add("facet_size", parameterToString(localVarOptionals.FacetSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Facets.IsSet() {
		t:=localVarOptionals.Facets.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("facets", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("facets", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GeoSamplesGet_6Opts Optional parameters for the method 'GeoSamplesGet_6'
type GeoSamplesGet_6Opts struct {
    Q optional.String
    Size optional.Int32
    Cursor optional.String
    FacetSize optional.Int32
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    Facets optional.Interface
}

/*
GeoSamplesGet_0 Samples
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *GeoSamplesGet_6Opts - Optional Parameters:
 * @param "Q" (optional.String) -  The query, using [lucene query syntax](https://lucene.apache.org/core/3_6_0/queryparsersyntax.html)
 * @param "Size" (optional.Int32) - 
 * @param "Cursor" (optional.String) -  The cursor is used to scroll through results. For a query with more results than `size`, the result will include `cursor` in the result json. Use that value here and re-issue the query. The next set or results will be returned. When no more results are available, the `cursor` will again be empty in the result json.
 * @param "FacetSize" (optional.Int32) -  The maximum number of records returned for each facet. This has no effect unless one or more facets are specified.
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
 * @param "Facets" (optional.Interface of []string) -  A list of strings identifying fields for faceted search results. Simple term faceting is used here, meaning that fields that are short text and repeated across records will be binned and counted.
@return ResponseModel
*/
func (a *GEOApiService) GeoSamplesGet_6(ctx _context.Context, localVarOptionals *GeoSamplesGet_6Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/geo/samples"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FacetSize.IsSet() {
		localVarQueryParams.Add("facet_size", parameterToString(localVarOptionals.FacetSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Facets.IsSet() {
		t:=localVarOptionals.Facets.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("facets", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("facets", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GeoSeriesGetOpts Optional parameters for the method 'GeoSeriesGet'
type GeoSeriesGetOpts struct {
    Q optional.String
    Size optional.Int32
    Cursor optional.String
    FacetSize optional.Int32
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    Facets optional.Interface
}

/*
GeoSeriesGet Series
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *GeoSeriesGetOpts - Optional Parameters:
 * @param "Q" (optional.String) -  The query, using [lucene query syntax](https://lucene.apache.org/core/3_6_0/queryparsersyntax.html)
 * @param "Size" (optional.Int32) - 
 * @param "Cursor" (optional.String) -  The cursor is used to scroll through results. For a query with more results than `size`, the result will include `cursor` in the result json. Use that value here and re-issue the query. The next set or results will be returned. When no more results are available, the `cursor` will again be empty in the result json.
 * @param "FacetSize" (optional.Int32) -  The maximum number of records returned for each facet. This has no effect unless one or more facets are specified.
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
 * @param "Facets" (optional.Interface of []string) -  A list of strings identifying fields for faceted search results. Simple term faceting is used here, meaning that fields that are short text and repeated across records will be binned and counted.
@return ResponseModel
*/
func (a *GEOApiService) GeoSeriesGet(ctx _context.Context, localVarOptionals *GeoSeriesGetOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/geo/series"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FacetSize.IsSet() {
		localVarQueryParams.Add("facet_size", parameterToString(localVarOptionals.FacetSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Facets.IsSet() {
		t:=localVarOptionals.Facets.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("facets", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("facets", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GeoSeriesGet_7Opts Optional parameters for the method 'GeoSeriesGet_7'
type GeoSeriesGet_7Opts struct {
    Q optional.String
    Size optional.Int32
    Cursor optional.String
    FacetSize optional.Int32
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    Facets optional.Interface
}

/*
GeoSeriesGet_0 Series
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *GeoSeriesGet_7Opts - Optional Parameters:
 * @param "Q" (optional.String) -  The query, using [lucene query syntax](https://lucene.apache.org/core/3_6_0/queryparsersyntax.html)
 * @param "Size" (optional.Int32) - 
 * @param "Cursor" (optional.String) -  The cursor is used to scroll through results. For a query with more results than `size`, the result will include `cursor` in the result json. Use that value here and re-issue the query. The next set or results will be returned. When no more results are available, the `cursor` will again be empty in the result json.
 * @param "FacetSize" (optional.Int32) -  The maximum number of records returned for each facet. This has no effect unless one or more facets are specified.
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
 * @param "Facets" (optional.Interface of []string) -  A list of strings identifying fields for faceted search results. Simple term faceting is used here, meaning that fields that are short text and repeated across records will be binned and counted.
@return ResponseModel
*/
func (a *GEOApiService) GeoSeriesGet_7(ctx _context.Context, localVarOptionals *GeoSeriesGet_7Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/geo/series"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FacetSize.IsSet() {
		localVarQueryParams.Add("facet_size", parameterToString(localVarOptionals.FacetSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Facets.IsSet() {
		t:=localVarOptionals.Facets.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("facets", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("facets", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
