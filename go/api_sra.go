/*
 * OmicIDX
 *
 *     The OmicIDX API documentation is available in three forms:  - [RapiDoc](/docs) - [OpenAPI/Swagger Interactive](/swatterdoc) - [ReDoc (more readable in some ways)](/redoc)  
 *
 * API version: 0.99
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"reflect"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// SRAApiService SRAApi service
type SRAApiService service

// ExperimentByAccessionSraExperimentsAccessionGetOpts Optional parameters for the method 'ExperimentByAccessionSraExperimentsAccessionGet'
type ExperimentByAccessionSraExperimentsAccessionGetOpts struct {
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
}

/*
ExperimentByAccessionSraExperimentsAccessionGet Experiment By Accession
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accession An accession for lookup
 * @param optional nil or *ExperimentByAccessionSraExperimentsAccessionGetOpts - Optional Parameters:
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
@return map[string]interface{}
*/
func (a *SRAApiService) ExperimentByAccessionSraExperimentsAccessionGet(ctx _context.Context, accession string, localVarOptionals *ExperimentByAccessionSraExperimentsAccessionGetOpts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/experiments/{accession}"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", _neturl.QueryEscape(parameterToString(accession, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExperimentByAccessionSraExperimentsAccessionGet_1Opts Optional parameters for the method 'ExperimentByAccessionSraExperimentsAccessionGet_1'
type ExperimentByAccessionSraExperimentsAccessionGet_1Opts struct {
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
}

/*
ExperimentByAccessionSraExperimentsAccessionGet_0 Experiment By Accession
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accession An accession for lookup
 * @param optional nil or *ExperimentByAccessionSraExperimentsAccessionGet_1Opts - Optional Parameters:
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
@return map[string]interface{}
*/
func (a *SRAApiService) ExperimentByAccessionSraExperimentsAccessionGet_1(ctx _context.Context, accession string, localVarOptionals *ExperimentByAccessionSraExperimentsAccessionGet_1Opts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/experiments/{accession}"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", _neturl.QueryEscape(parameterToString(accession, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExperimentsForSampleSraSamplesAccessionExperimentsGetOpts Optional parameters for the method 'ExperimentsForSampleSraSamplesAccessionExperimentsGet'
type ExperimentsForSampleSraSamplesAccessionExperimentsGetOpts struct {
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    Size optional.Int32
    Cursor optional.String
}

/*
ExperimentsForSampleSraSamplesAccessionExperimentsGet Experiments For Sample
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accession An accession for lookup
 * @param optional nil or *ExperimentsForSampleSraSamplesAccessionExperimentsGetOpts - Optional Parameters:
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
 * @param "Size" (optional.Int32) - 
 * @param "Cursor" (optional.String) - 
@return map[string]interface{}
*/
func (a *SRAApiService) ExperimentsForSampleSraSamplesAccessionExperimentsGet(ctx _context.Context, accession string, localVarOptionals *ExperimentsForSampleSraSamplesAccessionExperimentsGetOpts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/samples/{accession}/experiments"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", _neturl.QueryEscape(parameterToString(accession, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExperimentsForSampleSraSamplesAccessionExperimentsGet_2Opts Optional parameters for the method 'ExperimentsForSampleSraSamplesAccessionExperimentsGet_2'
type ExperimentsForSampleSraSamplesAccessionExperimentsGet_2Opts struct {
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    Size optional.Int32
    Cursor optional.String
}

/*
ExperimentsForSampleSraSamplesAccessionExperimentsGet_0 Experiments For Sample
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accession An accession for lookup
 * @param optional nil or *ExperimentsForSampleSraSamplesAccessionExperimentsGet_2Opts - Optional Parameters:
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
 * @param "Size" (optional.Int32) - 
 * @param "Cursor" (optional.String) - 
@return map[string]interface{}
*/
func (a *SRAApiService) ExperimentsForSampleSraSamplesAccessionExperimentsGet_2(ctx _context.Context, accession string, localVarOptionals *ExperimentsForSampleSraSamplesAccessionExperimentsGet_2Opts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/samples/{accession}/experiments"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", _neturl.QueryEscape(parameterToString(accession, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExperimentsForStudySraStudiesAccessionExperimentsGetOpts Optional parameters for the method 'ExperimentsForStudySraStudiesAccessionExperimentsGet'
type ExperimentsForStudySraStudiesAccessionExperimentsGetOpts struct {
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    Size optional.Int32
    Cursor optional.String
}

/*
ExperimentsForStudySraStudiesAccessionExperimentsGet Experiments For Study
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accession An accession for lookup
 * @param optional nil or *ExperimentsForStudySraStudiesAccessionExperimentsGetOpts - Optional Parameters:
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
 * @param "Size" (optional.Int32) - 
 * @param "Cursor" (optional.String) - 
@return map[string]interface{}
*/
func (a *SRAApiService) ExperimentsForStudySraStudiesAccessionExperimentsGet(ctx _context.Context, accession string, localVarOptionals *ExperimentsForStudySraStudiesAccessionExperimentsGetOpts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/studies/{accession}/experiments"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", _neturl.QueryEscape(parameterToString(accession, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExperimentsForStudySraStudiesAccessionExperimentsGet_3Opts Optional parameters for the method 'ExperimentsForStudySraStudiesAccessionExperimentsGet_3'
type ExperimentsForStudySraStudiesAccessionExperimentsGet_3Opts struct {
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    Size optional.Int32
    Cursor optional.String
}

/*
ExperimentsForStudySraStudiesAccessionExperimentsGet_0 Experiments For Study
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accession An accession for lookup
 * @param optional nil or *ExperimentsForStudySraStudiesAccessionExperimentsGet_3Opts - Optional Parameters:
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
 * @param "Size" (optional.Int32) - 
 * @param "Cursor" (optional.String) - 
@return map[string]interface{}
*/
func (a *SRAApiService) ExperimentsForStudySraStudiesAccessionExperimentsGet_3(ctx _context.Context, accession string, localVarOptionals *ExperimentsForStudySraStudiesAccessionExperimentsGet_3Opts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/studies/{accession}/experiments"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", _neturl.QueryEscape(parameterToString(accession, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExperimentsSraExperimentsGetOpts Optional parameters for the method 'ExperimentsSraExperimentsGet'
type ExperimentsSraExperimentsGetOpts struct {
    Q optional.String
    Size optional.Int32
    Cursor optional.String
    FacetSize optional.Int32
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    Facets optional.Interface
}

/*
ExperimentsSraExperimentsGet Experiments
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExperimentsSraExperimentsGetOpts - Optional Parameters:
 * @param "Q" (optional.String) -  The query, using [lucene query syntax](https://lucene.apache.org/core/3_6_0/queryparsersyntax.html)
 * @param "Size" (optional.Int32) - 
 * @param "Cursor" (optional.String) -  The cursor is used to scroll through results. For a query with more results than `size`, the result will include `cursor` in the result json. Use that value here and re-issue the query. The next set or results will be returned. When no more results are available, the `cursor` will again be empty in the result json.
 * @param "FacetSize" (optional.Int32) -  The maximum number of records returned for each facet. This has no effect unless one or more facets are specified.
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
 * @param "Facets" (optional.Interface of []string) -  A list of strings identifying fields for faceted search results. Simple term faceting is used here, meaning that fields that are short text and repeated across records will be binned and counted.
@return ResponseModel
*/
func (a *SRAApiService) ExperimentsSraExperimentsGet(ctx _context.Context, localVarOptionals *ExperimentsSraExperimentsGetOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/experiments"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FacetSize.IsSet() {
		localVarQueryParams.Add("facet_size", parameterToString(localVarOptionals.FacetSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Facets.IsSet() {
		t:=localVarOptionals.Facets.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("facets", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("facets", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExperimentsSraExperimentsGet_4Opts Optional parameters for the method 'ExperimentsSraExperimentsGet_4'
type ExperimentsSraExperimentsGet_4Opts struct {
    Q optional.String
    Size optional.Int32
    Cursor optional.String
    FacetSize optional.Int32
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    Facets optional.Interface
}

/*
ExperimentsSraExperimentsGet_0 Experiments
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExperimentsSraExperimentsGet_4Opts - Optional Parameters:
 * @param "Q" (optional.String) -  The query, using [lucene query syntax](https://lucene.apache.org/core/3_6_0/queryparsersyntax.html)
 * @param "Size" (optional.Int32) - 
 * @param "Cursor" (optional.String) -  The cursor is used to scroll through results. For a query with more results than `size`, the result will include `cursor` in the result json. Use that value here and re-issue the query. The next set or results will be returned. When no more results are available, the `cursor` will again be empty in the result json.
 * @param "FacetSize" (optional.Int32) -  The maximum number of records returned for each facet. This has no effect unless one or more facets are specified.
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
 * @param "Facets" (optional.Interface of []string) -  A list of strings identifying fields for faceted search results. Simple term faceting is used here, meaning that fields that are short text and repeated across records will be binned and counted.
@return ResponseModel
*/
func (a *SRAApiService) ExperimentsSraExperimentsGet_4(ctx _context.Context, localVarOptionals *ExperimentsSraExperimentsGet_4Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/experiments"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FacetSize.IsSet() {
		localVarQueryParams.Add("facet_size", parameterToString(localVarOptionals.FacetSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Facets.IsSet() {
		t:=localVarOptionals.Facets.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("facets", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("facets", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
MappingSraFieldsEntityGet Mapping
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param entity
@return map[string]interface{}
*/
func (a *SRAApiService) MappingSraFieldsEntityGet(ctx _context.Context, entity string) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/fields/{entity}"
	localVarPath = strings.Replace(localVarPath, "{"+"entity"+"}", _neturl.QueryEscape(parameterToString(entity, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// RunByAccessionSraRunsAccessionGetOpts Optional parameters for the method 'RunByAccessionSraRunsAccessionGet'
type RunByAccessionSraRunsAccessionGetOpts struct {
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
}

/*
RunByAccessionSraRunsAccessionGet Run By Accession
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accession An accession for lookup
 * @param optional nil or *RunByAccessionSraRunsAccessionGetOpts - Optional Parameters:
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
@return map[string]interface{}
*/
func (a *SRAApiService) RunByAccessionSraRunsAccessionGet(ctx _context.Context, accession string, localVarOptionals *RunByAccessionSraRunsAccessionGetOpts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/runs/{accession}"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", _neturl.QueryEscape(parameterToString(accession, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// RunByAccessionSraRunsAccessionGet_5Opts Optional parameters for the method 'RunByAccessionSraRunsAccessionGet_5'
type RunByAccessionSraRunsAccessionGet_5Opts struct {
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
}

/*
RunByAccessionSraRunsAccessionGet_0 Run By Accession
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accession An accession for lookup
 * @param optional nil or *RunByAccessionSraRunsAccessionGet_5Opts - Optional Parameters:
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
@return map[string]interface{}
*/
func (a *SRAApiService) RunByAccessionSraRunsAccessionGet_5(ctx _context.Context, accession string, localVarOptionals *RunByAccessionSraRunsAccessionGet_5Opts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/runs/{accession}"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", _neturl.QueryEscape(parameterToString(accession, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// RunsForExperimentSraExperimentsAccessionRunsGetOpts Optional parameters for the method 'RunsForExperimentSraExperimentsAccessionRunsGet'
type RunsForExperimentSraExperimentsAccessionRunsGetOpts struct {
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    Size optional.Int32
    Cursor optional.String
}

/*
RunsForExperimentSraExperimentsAccessionRunsGet Runs For Experiment
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accession An accession for lookup
 * @param optional nil or *RunsForExperimentSraExperimentsAccessionRunsGetOpts - Optional Parameters:
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
 * @param "Size" (optional.Int32) - 
 * @param "Cursor" (optional.String) - 
@return map[string]interface{}
*/
func (a *SRAApiService) RunsForExperimentSraExperimentsAccessionRunsGet(ctx _context.Context, accession string, localVarOptionals *RunsForExperimentSraExperimentsAccessionRunsGetOpts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/experiments/{accession}/runs"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", _neturl.QueryEscape(parameterToString(accession, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// RunsForExperimentSraExperimentsAccessionRunsGet_6Opts Optional parameters for the method 'RunsForExperimentSraExperimentsAccessionRunsGet_6'
type RunsForExperimentSraExperimentsAccessionRunsGet_6Opts struct {
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    Size optional.Int32
    Cursor optional.String
}

/*
RunsForExperimentSraExperimentsAccessionRunsGet_0 Runs For Experiment
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accession An accession for lookup
 * @param optional nil or *RunsForExperimentSraExperimentsAccessionRunsGet_6Opts - Optional Parameters:
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
 * @param "Size" (optional.Int32) - 
 * @param "Cursor" (optional.String) - 
@return map[string]interface{}
*/
func (a *SRAApiService) RunsForExperimentSraExperimentsAccessionRunsGet_6(ctx _context.Context, accession string, localVarOptionals *RunsForExperimentSraExperimentsAccessionRunsGet_6Opts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/experiments/{accession}/runs"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", _neturl.QueryEscape(parameterToString(accession, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// RunsForSampleSraSamplesAccessionRunsGetOpts Optional parameters for the method 'RunsForSampleSraSamplesAccessionRunsGet'
type RunsForSampleSraSamplesAccessionRunsGetOpts struct {
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    Size optional.Int32
    Cursor optional.String
}

/*
RunsForSampleSraSamplesAccessionRunsGet Runs For Sample
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accession An accession for lookup
 * @param optional nil or *RunsForSampleSraSamplesAccessionRunsGetOpts - Optional Parameters:
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
 * @param "Size" (optional.Int32) - 
 * @param "Cursor" (optional.String) - 
@return map[string]interface{}
*/
func (a *SRAApiService) RunsForSampleSraSamplesAccessionRunsGet(ctx _context.Context, accession string, localVarOptionals *RunsForSampleSraSamplesAccessionRunsGetOpts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/samples/{accession}/runs"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", _neturl.QueryEscape(parameterToString(accession, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// RunsForSampleSraSamplesAccessionRunsGet_7Opts Optional parameters for the method 'RunsForSampleSraSamplesAccessionRunsGet_7'
type RunsForSampleSraSamplesAccessionRunsGet_7Opts struct {
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    Size optional.Int32
    Cursor optional.String
}

/*
RunsForSampleSraSamplesAccessionRunsGet_0 Runs For Sample
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accession An accession for lookup
 * @param optional nil or *RunsForSampleSraSamplesAccessionRunsGet_7Opts - Optional Parameters:
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
 * @param "Size" (optional.Int32) - 
 * @param "Cursor" (optional.String) - 
@return map[string]interface{}
*/
func (a *SRAApiService) RunsForSampleSraSamplesAccessionRunsGet_7(ctx _context.Context, accession string, localVarOptionals *RunsForSampleSraSamplesAccessionRunsGet_7Opts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/samples/{accession}/runs"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", _neturl.QueryEscape(parameterToString(accession, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// RunsForStudySraStudiesAccessionRunsGetOpts Optional parameters for the method 'RunsForStudySraStudiesAccessionRunsGet'
type RunsForStudySraStudiesAccessionRunsGetOpts struct {
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    Size optional.Int32
    Cursor optional.String
}

/*
RunsForStudySraStudiesAccessionRunsGet Runs For Study
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accession An accession for lookup
 * @param optional nil or *RunsForStudySraStudiesAccessionRunsGetOpts - Optional Parameters:
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
 * @param "Size" (optional.Int32) - 
 * @param "Cursor" (optional.String) - 
@return map[string]interface{}
*/
func (a *SRAApiService) RunsForStudySraStudiesAccessionRunsGet(ctx _context.Context, accession string, localVarOptionals *RunsForStudySraStudiesAccessionRunsGetOpts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/studies/{accession}/runs"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", _neturl.QueryEscape(parameterToString(accession, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// RunsForStudySraStudiesAccessionRunsGet_8Opts Optional parameters for the method 'RunsForStudySraStudiesAccessionRunsGet_8'
type RunsForStudySraStudiesAccessionRunsGet_8Opts struct {
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    Size optional.Int32
    Cursor optional.String
}

/*
RunsForStudySraStudiesAccessionRunsGet_0 Runs For Study
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accession An accession for lookup
 * @param optional nil or *RunsForStudySraStudiesAccessionRunsGet_8Opts - Optional Parameters:
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
 * @param "Size" (optional.Int32) - 
 * @param "Cursor" (optional.String) - 
@return map[string]interface{}
*/
func (a *SRAApiService) RunsForStudySraStudiesAccessionRunsGet_8(ctx _context.Context, accession string, localVarOptionals *RunsForStudySraStudiesAccessionRunsGet_8Opts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/studies/{accession}/runs"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", _neturl.QueryEscape(parameterToString(accession, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// RunsSraRunsGetOpts Optional parameters for the method 'RunsSraRunsGet'
type RunsSraRunsGetOpts struct {
    Q optional.String
    Size optional.Int32
    Cursor optional.String
    FacetSize optional.Int32
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    Facets optional.Interface
}

/*
RunsSraRunsGet Runs
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *RunsSraRunsGetOpts - Optional Parameters:
 * @param "Q" (optional.String) -  The query, using [lucene query syntax](https://lucene.apache.org/core/3_6_0/queryparsersyntax.html)
 * @param "Size" (optional.Int32) - 
 * @param "Cursor" (optional.String) -  The cursor is used to scroll through results. For a query with more results than `size`, the result will include `cursor` in the result json. Use that value here and re-issue the query. The next set or results will be returned. When no more results are available, the `cursor` will again be empty in the result json.
 * @param "FacetSize" (optional.Int32) -  The maximum number of records returned for each facet. This has no effect unless one or more facets are specified.
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
 * @param "Facets" (optional.Interface of []string) -  A list of strings identifying fields for faceted search results. Simple term faceting is used here, meaning that fields that are short text and repeated across records will be binned and counted.
@return ResponseModel
*/
func (a *SRAApiService) RunsSraRunsGet(ctx _context.Context, localVarOptionals *RunsSraRunsGetOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/runs"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FacetSize.IsSet() {
		localVarQueryParams.Add("facet_size", parameterToString(localVarOptionals.FacetSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Facets.IsSet() {
		t:=localVarOptionals.Facets.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("facets", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("facets", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// RunsSraRunsGet_9Opts Optional parameters for the method 'RunsSraRunsGet_9'
type RunsSraRunsGet_9Opts struct {
    Q optional.String
    Size optional.Int32
    Cursor optional.String
    FacetSize optional.Int32
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    Facets optional.Interface
}

/*
RunsSraRunsGet_0 Runs
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *RunsSraRunsGet_9Opts - Optional Parameters:
 * @param "Q" (optional.String) -  The query, using [lucene query syntax](https://lucene.apache.org/core/3_6_0/queryparsersyntax.html)
 * @param "Size" (optional.Int32) - 
 * @param "Cursor" (optional.String) -  The cursor is used to scroll through results. For a query with more results than `size`, the result will include `cursor` in the result json. Use that value here and re-issue the query. The next set or results will be returned. When no more results are available, the `cursor` will again be empty in the result json.
 * @param "FacetSize" (optional.Int32) -  The maximum number of records returned for each facet. This has no effect unless one or more facets are specified.
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
 * @param "Facets" (optional.Interface of []string) -  A list of strings identifying fields for faceted search results. Simple term faceting is used here, meaning that fields that are short text and repeated across records will be binned and counted.
@return ResponseModel
*/
func (a *SRAApiService) RunsSraRunsGet_9(ctx _context.Context, localVarOptionals *RunsSraRunsGet_9Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/runs"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FacetSize.IsSet() {
		localVarQueryParams.Add("facet_size", parameterToString(localVarOptionals.FacetSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Facets.IsSet() {
		t:=localVarOptionals.Facets.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("facets", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("facets", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SampleByAccessionSraSamplesAccessionGetOpts Optional parameters for the method 'SampleByAccessionSraSamplesAccessionGet'
type SampleByAccessionSraSamplesAccessionGetOpts struct {
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
}

/*
SampleByAccessionSraSamplesAccessionGet Sample By Accession
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accession An accession for lookup
 * @param optional nil or *SampleByAccessionSraSamplesAccessionGetOpts - Optional Parameters:
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
@return map[string]interface{}
*/
func (a *SRAApiService) SampleByAccessionSraSamplesAccessionGet(ctx _context.Context, accession string, localVarOptionals *SampleByAccessionSraSamplesAccessionGetOpts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/samples/{accession}"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", _neturl.QueryEscape(parameterToString(accession, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SampleByAccessionSraSamplesAccessionGet_10Opts Optional parameters for the method 'SampleByAccessionSraSamplesAccessionGet_10'
type SampleByAccessionSraSamplesAccessionGet_10Opts struct {
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
}

/*
SampleByAccessionSraSamplesAccessionGet_0 Sample By Accession
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accession An accession for lookup
 * @param optional nil or *SampleByAccessionSraSamplesAccessionGet_10Opts - Optional Parameters:
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
@return map[string]interface{}
*/
func (a *SRAApiService) SampleByAccessionSraSamplesAccessionGet_10(ctx _context.Context, accession string, localVarOptionals *SampleByAccessionSraSamplesAccessionGet_10Opts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/samples/{accession}"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", _neturl.QueryEscape(parameterToString(accession, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SamplesForStudySraStudiesAccessionSamplesGetOpts Optional parameters for the method 'SamplesForStudySraStudiesAccessionSamplesGet'
type SamplesForStudySraStudiesAccessionSamplesGetOpts struct {
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    Size optional.Int32
    Cursor optional.String
}

/*
SamplesForStudySraStudiesAccessionSamplesGet Samples For Study
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accession An accession for lookup
 * @param optional nil or *SamplesForStudySraStudiesAccessionSamplesGetOpts - Optional Parameters:
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
 * @param "Size" (optional.Int32) - 
 * @param "Cursor" (optional.String) - 
@return map[string]interface{}
*/
func (a *SRAApiService) SamplesForStudySraStudiesAccessionSamplesGet(ctx _context.Context, accession string, localVarOptionals *SamplesForStudySraStudiesAccessionSamplesGetOpts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/studies/{accession}/samples"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", _neturl.QueryEscape(parameterToString(accession, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SamplesForStudySraStudiesAccessionSamplesGet_11Opts Optional parameters for the method 'SamplesForStudySraStudiesAccessionSamplesGet_11'
type SamplesForStudySraStudiesAccessionSamplesGet_11Opts struct {
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    Size optional.Int32
    Cursor optional.String
}

/*
SamplesForStudySraStudiesAccessionSamplesGet_0 Samples For Study
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accession An accession for lookup
 * @param optional nil or *SamplesForStudySraStudiesAccessionSamplesGet_11Opts - Optional Parameters:
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
 * @param "Size" (optional.Int32) - 
 * @param "Cursor" (optional.String) - 
@return map[string]interface{}
*/
func (a *SRAApiService) SamplesForStudySraStudiesAccessionSamplesGet_11(ctx _context.Context, accession string, localVarOptionals *SamplesForStudySraStudiesAccessionSamplesGet_11Opts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/studies/{accession}/samples"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", _neturl.QueryEscape(parameterToString(accession, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SamplesSraSamplesGetOpts Optional parameters for the method 'SamplesSraSamplesGet'
type SamplesSraSamplesGetOpts struct {
    Q optional.String
    Size optional.Int32
    Cursor optional.String
    FacetSize optional.Int32
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    Facets optional.Interface
}

/*
SamplesSraSamplesGet Samples
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *SamplesSraSamplesGetOpts - Optional Parameters:
 * @param "Q" (optional.String) -  The query, using [lucene query syntax](https://lucene.apache.org/core/3_6_0/queryparsersyntax.html)
 * @param "Size" (optional.Int32) - 
 * @param "Cursor" (optional.String) -  The cursor is used to scroll through results. For a query with more results than `size`, the result will include `cursor` in the result json. Use that value here and re-issue the query. The next set or results will be returned. When no more results are available, the `cursor` will again be empty in the result json.
 * @param "FacetSize" (optional.Int32) -  The maximum number of records returned for each facet. This has no effect unless one or more facets are specified.
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
 * @param "Facets" (optional.Interface of []string) -  A list of strings identifying fields for faceted search results. Simple term faceting is used here, meaning that fields that are short text and repeated across records will be binned and counted.
@return ResponseModel
*/
func (a *SRAApiService) SamplesSraSamplesGet(ctx _context.Context, localVarOptionals *SamplesSraSamplesGetOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/samples"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FacetSize.IsSet() {
		localVarQueryParams.Add("facet_size", parameterToString(localVarOptionals.FacetSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Facets.IsSet() {
		t:=localVarOptionals.Facets.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("facets", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("facets", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SamplesSraSamplesGet_12Opts Optional parameters for the method 'SamplesSraSamplesGet_12'
type SamplesSraSamplesGet_12Opts struct {
    Q optional.String
    Size optional.Int32
    Cursor optional.String
    FacetSize optional.Int32
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    Facets optional.Interface
}

/*
SamplesSraSamplesGet_0 Samples
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *SamplesSraSamplesGet_12Opts - Optional Parameters:
 * @param "Q" (optional.String) -  The query, using [lucene query syntax](https://lucene.apache.org/core/3_6_0/queryparsersyntax.html)
 * @param "Size" (optional.Int32) - 
 * @param "Cursor" (optional.String) -  The cursor is used to scroll through results. For a query with more results than `size`, the result will include `cursor` in the result json. Use that value here and re-issue the query. The next set or results will be returned. When no more results are available, the `cursor` will again be empty in the result json.
 * @param "FacetSize" (optional.Int32) -  The maximum number of records returned for each facet. This has no effect unless one or more facets are specified.
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
 * @param "Facets" (optional.Interface of []string) -  A list of strings identifying fields for faceted search results. Simple term faceting is used here, meaning that fields that are short text and repeated across records will be binned and counted.
@return ResponseModel
*/
func (a *SRAApiService) SamplesSraSamplesGet_12(ctx _context.Context, localVarOptionals *SamplesSraSamplesGet_12Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/samples"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FacetSize.IsSet() {
		localVarQueryParams.Add("facet_size", parameterToString(localVarOptionals.FacetSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Facets.IsSet() {
		t:=localVarOptionals.Facets.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("facets", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("facets", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// StudiesSraStudiesGetOpts Optional parameters for the method 'StudiesSraStudiesGet'
type StudiesSraStudiesGetOpts struct {
    Q optional.String
    Size optional.Int32
    Cursor optional.String
    FacetSize optional.Int32
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    Facets optional.Interface
}

/*
StudiesSraStudiesGet Studies
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *StudiesSraStudiesGetOpts - Optional Parameters:
 * @param "Q" (optional.String) -  The query, using [lucene query syntax](https://lucene.apache.org/core/3_6_0/queryparsersyntax.html)
 * @param "Size" (optional.Int32) - 
 * @param "Cursor" (optional.String) -  The cursor is used to scroll through results. For a query with more results than `size`, the result will include `cursor` in the result json. Use that value here and re-issue the query. The next set or results will be returned. When no more results are available, the `cursor` will again be empty in the result json.
 * @param "FacetSize" (optional.Int32) -  The maximum number of records returned for each facet. This has no effect unless one or more facets are specified.
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
 * @param "Facets" (optional.Interface of []string) -  A list of strings identifying fields for faceted search results. Simple term faceting is used here, meaning that fields that are short text and repeated across records will be binned and counted.
@return ResponseModel
*/
func (a *SRAApiService) StudiesSraStudiesGet(ctx _context.Context, localVarOptionals *StudiesSraStudiesGetOpts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/studies"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FacetSize.IsSet() {
		localVarQueryParams.Add("facet_size", parameterToString(localVarOptionals.FacetSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Facets.IsSet() {
		t:=localVarOptionals.Facets.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("facets", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("facets", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// StudiesSraStudiesGet_13Opts Optional parameters for the method 'StudiesSraStudiesGet_13'
type StudiesSraStudiesGet_13Opts struct {
    Q optional.String
    Size optional.Int32
    Cursor optional.String
    FacetSize optional.Int32
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    Facets optional.Interface
}

/*
StudiesSraStudiesGet_0 Studies
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *StudiesSraStudiesGet_13Opts - Optional Parameters:
 * @param "Q" (optional.String) -  The query, using [lucene query syntax](https://lucene.apache.org/core/3_6_0/queryparsersyntax.html)
 * @param "Size" (optional.Int32) - 
 * @param "Cursor" (optional.String) -  The cursor is used to scroll through results. For a query with more results than `size`, the result will include `cursor` in the result json. Use that value here and re-issue the query. The next set or results will be returned. When no more results are available, the `cursor` will again be empty in the result json.
 * @param "FacetSize" (optional.Int32) -  The maximum number of records returned for each facet. This has no effect unless one or more facets are specified.
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
 * @param "Facets" (optional.Interface of []string) -  A list of strings identifying fields for faceted search results. Simple term faceting is used here, meaning that fields that are short text and repeated across records will be binned and counted.
@return ResponseModel
*/
func (a *SRAApiService) StudiesSraStudiesGet_13(ctx _context.Context, localVarOptionals *StudiesSraStudiesGet_13Opts) (ResponseModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/studies"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FacetSize.IsSet() {
		localVarQueryParams.Add("facet_size", parameterToString(localVarOptionals.FacetSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Facets.IsSet() {
		t:=localVarOptionals.Facets.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("facets", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("facets", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// StudyByAccessionSraStudiesAccessionGetOpts Optional parameters for the method 'StudyByAccessionSraStudiesAccessionGet'
type StudyByAccessionSraStudiesAccessionGetOpts struct {
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
}

/*
StudyByAccessionSraStudiesAccessionGet Study By Accession
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accession An accession for lookup
 * @param optional nil or *StudyByAccessionSraStudiesAccessionGetOpts - Optional Parameters:
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
@return map[string]interface{}
*/
func (a *SRAApiService) StudyByAccessionSraStudiesAccessionGet(ctx _context.Context, accession string, localVarOptionals *StudyByAccessionSraStudiesAccessionGetOpts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/studies/{accession}"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", _neturl.QueryEscape(parameterToString(accession, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// StudyByAccessionSraStudiesAccessionGet_14Opts Optional parameters for the method 'StudyByAccessionSraStudiesAccessionGet_14'
type StudyByAccessionSraStudiesAccessionGet_14Opts struct {
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
}

/*
StudyByAccessionSraStudiesAccessionGet_0 Study By Accession
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accession An accession for lookup
 * @param optional nil or *StudyByAccessionSraStudiesAccessionGet_14Opts - Optional Parameters:
 * @param "IncludeFields" (optional.Interface of []string) -  Fields to include in results. The default is to all fields (*)
 * @param "ExcludeFields" (optional.Interface of []string) -  Fields to exclude from results. The default is to not exclude any fields. 
@return map[string]interface{}
*/
func (a *SRAApiService) StudyByAccessionSraStudiesAccessionGet_14(ctx _context.Context, accession string, localVarOptionals *StudyByAccessionSraStudiesAccessionGet_14Opts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/sra/studies/{accession}"
	localVarPath = strings.Replace(localVarPath, "{"+"accession"+"}", _neturl.QueryEscape(parameterToString(accession, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		t:=localVarOptionals.IncludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_fields", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		t:=localVarOptionals.ExcludeFields.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exclude_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exclude_fields", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HttpValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
